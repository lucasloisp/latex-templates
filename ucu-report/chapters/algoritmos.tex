\section{Hash de contrase√±as: Bcrypt}\label{secc:bcrypt}

Bcrypt es un algoritmo de hash que apunta a ser lento
\autocite{stackexchange-bcrypt}.
El algoritmo deriva del codificador de bloques sim√©tricos Blowfish, y es lento
por dise√±o, ya que su uso es proteger contrase√±as, y hace as√≠ m√°s dif√≠cil un
ataque de diccionario \autocite{auth0-bcrypt}.

Se considera el est√°ndar \emph{defacto} para el almacenamiento de contrase√±as
\autocite{itblog-pwhash}, dada una de sus caracter√≠sticas: el poder adaptarse
al nuevo hardware (m√°s r√°pido) haci√©ndose a√∫n m√°s lento con el ajuste de un
par√°metro \autocite{auth0-bcrypt}. 
Otra ventaja es que incluye por defecto el uso de \emph{salting}
\autocite{stackexchange-bcryptsalt} y evita as√≠ ataques de \emph{rainbow
table}.
Este valor se almacena codificado en el valor resultante lo que permite
verificar mas adelante una contrase√±a repitiendo el proceso con el mismo
valor para salt.

\section{Derivaci√≥n de Claves: Argon2}\label{secc:argon}

El algoritmo recomendado por la ``Password Hashing Competition'' \autocite{phc},
que eval√∫a algoritmos con un proceso similar a NIST en sus competencias AES y
SHA-3.
Es el algoritmo elegido por KeePass, un administrador de contrase√±as de c√≥digo
libre, para derivar una clave y cifrar los datos \autocite{keepass}.

Utiliza un salt (\autoref{secc:bcrypt}) para calcular sus hashes.
Este hash lo generamos al igual que el token (\autoref{secc:token}),
un vector de 16 bytes (128 bits, que es el defecto de la librer√≠a) con valores
aleatorios.

Para generar una clave usamos los siguientes par√°metros:
\begin{itemize}
	\item 5 iteraciones
	\item 65536 kibibytes de memoria utilizados
	\item 1 solo hilo para calcularlo
\end{itemize}

Los valores de estos par√°metros son los b√°sicos recomendados por la 
documentaci√≥n.~\cite{argon2-jvm}
Al llevar esta aplicaci√≥n a su hardware de servidor final de deben ajustar estos
par√°metros, ya que la idea es que sean tan altos como sea posible antes de que
afecten negativamente la experiencia del usuario (ya que tomar√°n mas tiempo).

Este es un beneficio de Argon2 (al igual que de Bcrypt) ya que pueden ajustar
su ``costo'' e \emph{ineficiencia} a medida que mejora el hardware haciendo m√°s 
dif√≠ciles los ataques de fuerza bruta.

Almacenamos el valor de salt en la base de datos, tabla \code{Usuario}, para
poder m√°s adelante repetir el proceso, y obtener la misma clave derivada.


\section{Cifrado sim√©trico de archivos}

\subsection{AES}\label{secc:aes}

El algoritmo AES es el algoritmo de elecci√≥n para la mayor√≠a de aplicaciones 
modernas que busquen proteger datos o archivos \autocite{cryptomathic-aes}.

El cifrado tiene una longitud variable de bloque y de clave, con
especificaciones para claves con una longitud de 128, 192 o 256 bits para cifrar 
bloques con una longitud de 128, 192 o 256 bits. Tanto la longitud del bloque 
como la longitud de la clave se pueden extender por 
m√∫ltiplos de 32 bits \cite{coulouris}.

Aunque una clave mayor hace m√°s dif√≠cil que esta se descubra tambi√©n hace m√°s
lento el proceso, por lo que se debe pesar el valor riesgo contra el impacto
en uso de recursos para decidir qu√© algoritmo usar.
AES con claves de 256 bits, por ejemplo, es un 40\% m√°s lento que su uso con claves
de 192 bits \autocite{solarwinds-aes}.
Considerando sin embargo que nuestra aplicaci√≥n busca proteger los datos de los
usuarios durante su intercambio elegimos AES-256.

\subsection{Blowfish}\label{secc:blowfish}

Este algoritmo tiene un tama√±o de bloque de 64 bits y un tama√±o de clave que 
var√≠a de 32 a 448 bits y se optimiz√≥ para CPU de 32 bits. Puede ser usado como 
reemplazo para DES o IDEA \cite{schneier}

Al d√≠a de hoy se considera un algoritmo de cifrado seguro, aunque al usar un 
bloque de 64 bits es vulnerable a un tipo espec√≠fico de ataque criptogr√°fico 
de fuerza bruta conocido como \emph{birthday attack} \cite{geeksBlowfish}.

\subsection{TEA}\label{secc:tea}

Este algoritmo est√° programado en C y utiliza un bloque de 64 bits representado 
por dos enteros de 32 bits en el vector llamado \emph{text[]}. 
La clave es de 128 bits, representada por cuatro enteros de 32 bits. 
TEA es tiene la capacidad de proveer un encriptado de clave secreta 
razonablemente r√°pido y seguro. Se destaca por ser un programa muy consiso, lo 
favorece la optimizaci√≥n y la implementaci√≥n por hardware.
Tambi√©n se conoce que es m√°s r√°pido que el algor√≠tmo DES \cite{coulouris}.
%TODO: Es seguro hoy en dia?
Una desventaja es que este algoritmo es vulnerable a los ataques de claves 
relacionadas. Esto no es un problema cuando la clave es aleatoria, pero tampoco 
inspira confianza, ya que esta vulnerabilidad y la posiblidad de la existencia de 
claves equivalentes triviales no fueron consideradas en el art√≠culo original 
\cite{stackexchange-crypto-tea}.

Este algoritmo generalmente es seguro cuando se cumplen las siguientes 
condiciones: 
las claves son aleatorias (el cambio de clave debe ser at√≥mico y con una nueva 
clave aleatoria); el tama√±o del bloque de 64 bits no es una preocupaci√≥n,
(por ejemplo, se usa un modo de operaci√≥n diferente al ECB y la clave se cambia 
antes de un valor de 1GB de datos); la relativa lentitud no es un obst√°culo; 
los ataques de canales laterales no son un problema \cite{stackexchange-crypto-tea}.

%https://crypto.stackexchange.com/questions/16186/is-tea-considered-secure

\subsection{DES y 3DES}\label{secc:DES}

Su funci√≥n de encriptado mapea una entrada de texto plano de 64 bits a una 
salida encriptada de 64 bits, utilizando una clave de 56 bits \cite{coulouris}.
En 1997 se demostr√≥ que este algor√≠tmo es vulnerable a ataques de fuerza bruta 
mediante un ataque exitoso de ese tipo y por lo tanto debe ser considerado 
obsoleto para la protecci√≥n de cualquier tipo de informaci√≥n, con excepci√≥n de 
aquella que sea de poco valor \cite{coulouris}.

Una alternativa es utilizar \emph{3DES (triple-DES)} que consiste en aplicar DES 
tres veces y con dos claves, K\textsubscript{1} y K\textsubscript{2}:

\[E\textsubscript{3DES}(K\textsubscript{1}, K\textsubscript{2}, M) = 
E\textsubscript{DES}(K\textsubscript{1}, D\textsubscript{DES}
(K\textsubscript{2}, E\textsubscript{DES}(K\textsubscript{1}, M)))\]

Esto le da una robust√©z contra los ataques de fuerza bruta equivalente a la que 
se tiene cuando se usa una clave de 112 bits pero tiene la desventaja de tener 
mal rendimiento, que resulta de la aplicaci√≥n triple de un algoritmo que ya es 
lento de por s√≠ seg√∫n est√°ndares modernos \cite{coulouris}.

\begin{figure}[H]
    \centering
        \includegraphics{img/rendimientoAlgoritmos.PNG}
    \caption{Rendimiento de algoritmos de cifrado sim√©trico y 
    \emph{secure digest} \cite{coulouris}.}
    \label{tabla:rendimiento}
\end{figure}


% TODO: source https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/TechGuidelines/TG02102/BSI-TR-02102-1.pdf;jsessionid=139E7E1917DFDEAF23598BDC2CE60B01.1_cid341?__blob=publicationFile&v=9

\section{Cifrado Asim√©trico}

\subsection{RSA}\label{secc:rsa}

Este algoritmo se basa en el uso del producto de dos n√∫meros primos que son 
\(> 10^{100}\), respaldandose en el hecho de que la determinaci√≥n de los factores 
primos de n√∫meros tan grandes es un proceso muy costoso a nivel computacional y 
tomar√≠a una gran cantidad de tiempo, a√∫n en computadoras de alto rendimiento. 
El producto de dos n√∫meros que son  \(> 10^{100}\) es  
\(> 10^{200}\) y la factorizaci√≥n de dicho n√∫mero, seg√∫n un c√°lculo realizado 
en 2012, puede demorar alrededor de un millon de a√±os. 
A pesar de que se han realizado extensas investigaciones, no se le encontraron 
fallas y es ampliamente utilizado hoy en d√≠a \cite{coulouris}.

Vale la pena se√±alar una debilidad potencial de todos los algoritmos de clave 
p√∫blica es que, como la clave p√∫blica est√° disponible para los atacantes, estos pueden 
generar f√°cilmente mensajes cifrados.
Por lo tanto, pueden intentar descifrar un mensaje desconocido cifrando exhaustivamente
secuencias de bits arbitrarias hasta que se logra una coincidencia con el mensaje 
de destino. Este ataque que se conoce como un \emph{chosen plaintext attack}, se 
vence asegurando que todos los mensajes
sean m√°s largos que la longitud de la clave, por lo que esta forma de ataque de 
fuerza bruta es menos factible que un ataque directo a la llave \cite{coulouris}.

RSA y otras formas de criptograf√≠a asim√©trica que usan la multiplicaci√≥n de 
n√∫meros primos como su \emph{one-way function} ser√°n vulnerables si se descubre 
un algoritmo de factorizaci√≥n m√°s r√°pido \cite{coulouris}.

\subsection{Algoritmos de curvas el√≠pticas}\label{secc:elliptic}

Estos algoritmos generan los pares de claves p√∫blica/privada basandose en las 
propiedades de las curvas 
el√≠pticas. A diferencia de RSA, su seguridad no depende de la dificultad de 
factorizar n√∫meros grandes.
Las principales ventajas que ofecen sobre RSA son que los requerimientos de 
procesamiento para el cifrado y el descifrado son menores y que claves 
m√°s peque√±as tambi√©n son seguras \cite{coulouris}.

Lamentablemente no existen muchas API's disponibles que implementen este tipo de 
algoritmos, y se mantengan actualizadas. La m√°s utilizada parece ser una 
llamada \emph{Bouncy Castle Crypto API} que funciona con Java y C\#, 
y presenta el paquete org.bouncycastle.crypto.ec que contiene implementaciones 
para una variedad de transformaciones criptogr√°ficas de curvas el√≠pticas como 
\emph{EC ElGamal} \cite{bouncycastle}.

\section{Protocolos criptogr√°ficos h√≠bridos}\label{secc:hybrid}
Dado que los algoritmos de cifrado sim√©trico son significativamente m√°s r√°pidos 
que los asim√©tricos, 
si se intenta cifrar un archivo pesado con cifrado asim√©trico, el proceso de 
cifrado y descifrado va a requerir demasiado tiempo. 
En cambio, si se encripta solo la clave sim√©trica mediante cifrado asim√©trico 
y luego se utiliza la clave sim√©trica para cifrar y descifrar el archivo 
pesado, el proceso de encripci√≥n ser√° m√°s r√°pido y eficiente. 
\cite{stackexchange-hybrid}.

Este tipo de combinaci√≥n tambi√©n permite cifrar el mensaje eficientemente para 
m√∫ltiples destinatarios. Si solamente se utilizara el cifrado asim√©trico, se 
tendr√≠a que cifrar todo 
el mensaje varias veces, una vez para cada destinatario. Pero con el cifrado 
h√≠brido solo se necesita cifrar varias copias de la clave sim√©trica y una 
copia del mensaje \cite{stackexchange-hybrid}.

% TODO: Lo comento porque en no hacemos esto, y quedamos en offside üòÜ
% Otra ventaja del cifrado h√≠brido es que nunca env√≠a el mismo texto cifrado dos 
% veces. Se genera, o se debe generar, una nueva clave sim√©trica para cada mensaje. 
% Esto significa que cuando el mismo texto plano se cifra dos veces para un  
% mismo receptor, los cifrados se ver√°n diferentes. Mientras que si se utilizara 
% √∫nicamente la clave p√∫blica, ambos cifrados ser√≠an id√©nticos \cite{stackexchange-hybrid}.

Debido a las ventajas que presenta un protocolo h√≠brido, el sistema desarrollado 
(\autoref{secc:esquemacifrado}) implementa un protocolo 
criptogr√°fico h√≠brido en el que se utiliza RSA para el cifrado asim√©trico 
\autocite{ppt202}, con claves de 2048 bits y AES-256 para el sim√©trico. 
M√°s adelante se justifica la elecci√≥n de los algoritmos.

\section{Justificaci√≥n de los algoritmos elegidos}

Con la finalidad de proteger el sistema de la mejor manera se elige 
utlizar un sistema h√≠brido con los siguentes algoritmos.

Para el cifrado sim√©trico se elige utilizar AES-256 CBC por varias razones. 
La princial es que, como la NSA 
considera que la utilizaci√≥n de este algoritmo con ese largo de clave es 
suficiente para proteger informaci√≥n clasificada de todos los 
niveles, hasta TOP SECRET, consideramos que tiene excelentes referencias y que 
es m√°s que suficiente para proteger nuestro sistema. Tambi√©n por la alta 
disponibilidad de librer√≠as confiables y actualizadas que permiten una 
implementaci√≥n segura y robusta del algoritmo. De los algoritmos disponibles es 
de los que ofrece mejor rendimiento (\autoref{tabla:rendimiento}) y seguridad, 
ya que en aproximadamente 19 a√±os desde su publicaci√≥n no se conocen ataques 
que afecten gravemente la seguridad del algoritmo. 

Si bien existen ataques de 
canal lateral contra algunas implementaciones de AES, no existen ataques 
criptoanal√≠ticos pr√°cticos contra el algoritmo abstracto. 
El mejor ataque criptoanal√≠tico contra el cifrado completo en un modelo de 
ataque razonable es probablemente el ataque \emph{biclique}, que quita como m√°ximo 4 
bits de la clave.
En el caso de que se quitaran 4 bits de la clave, quedar√≠an todavia 252 bits. 
Dicho de otra manera, para llevar a cabo estos ataques se necesitar√≠a gastar un esfuerzo 
aproximadamente proporcional a un ataque de fuerza bruta forzando una clave AES 
donde ya conoc√≠an cuatro bits de la clave y esto tomar√≠a aproximadamente \(2^{252}\)
operaciones, manteniendo un margen de seguridad m√°s que suficiente 
\cite{stackexchange-crypto-biclique}.

Para el cifrado asim√©trico se elige RSA con claves de 2048 bits que es el largo 
de clave recomendado por NIST \cite{NIST-RSA}. En cuanto a los ataques posibles 
contra este algoritmo, si bien se han realizado una cantidad de ataques, 
ninguno de estos es devastador.

Se elige este tipo de algoritmo por sobre los de curvas el√≠pticas porque hay  
una mayor cantidad de librerias disponibles que lo implementan de manera segura 
y que han sido probadas exhaustivamente.
